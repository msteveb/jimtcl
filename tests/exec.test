# Commands covered:  exec
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: exec.test,v 1.8.2.1 2001/10/17 19:29:25 das Exp $

source [file dirname [info script]]/testing.tcl

needs cmd exec
needs cmd flush
needs cmd after eventloop

# Windows does not have these Linux utilities - also echo & cat are not executable files
testConstraint posixUtilsAvailable [expr ! ( [catch { exec echo } fid] || [catch { exec cat --help} fid] || [catch { exec sh --help} fid] || [catch { exec ps --help} fid] || [catch { exec fgrep --help} fid] || [catch { exec wc --help} fid]) ]

# Additionally Windows will fail the long commandline test - even on MinGW which does have the Linux utilities above
testConstraint commandLengthLimit [expr ! [catch { win32.GetVersion } fid] ]


# Sleep which supports fractions of a second
if {[info commands sleep] eq {}} {
    proc sleep {n} {
	after [expr {int($n * 1000)}]
    }
}

set f [open sleepx w]
puts $f "#![info nameofexecutable]"
puts $f {
    set seconds [lindex $argv 0]
    after [expr {int($seconds * 1000)}]
}
close $f
#catch {exec chmod +x sleepx}
set sleepx [list [info nameofexecutable] sleepx]

# Basic operations.

test exec-1.1 {basic exec operation} -constraints {posixUtilsAvailable} -body {
    exec echo a b c
} -result "a b c"
test exec-1.2 {pipelining} -constraints {posixUtilsAvailable} -body {
    exec echo a b c d | cat | cat
} -result "a b c d"
test exec-1.3 {pipelining} -constraints {posixUtilsAvailable} -body {
    set a [exec echo a b c d | cat | wc]
    list [scan $a "%d %d %d" b c d] $b $c
} -result {3 1 4}
set arg {12345678901234567890123456789012345678901234567890}
set arg "$arg$arg$arg$arg$arg$arg"
test exec-1.4 {long command lines} -constraints {posixUtilsAvailable} -body {
    exec echo $arg
} -result $arg
set arg {}

# I/O redirection: input from Tcl command.

test exec-2.1 {redirecting input from immediate source} -constraints {posixUtilsAvailable} -body {
    exec cat << "Sample text"
} -result {Sample text}
test exec-2.2 {redirecting input from immediate source} -constraints {posixUtilsAvailable} -body {
    exec << "Sample text" cat | cat
} -result {Sample text}
test exec-2.3 {redirecting input from immediate source} -constraints {posixUtilsAvailable} -body {
    exec cat << "Sample text" | cat
} -result {Sample text}
test exec-2.4 {redirecting input from immediate source} -constraints {posixUtilsAvailable} -body {
    exec cat | cat << "Sample text"
} -result {Sample text}
test exec-2.5 {redirecting input from immediate source} -constraints {posixUtilsAvailable} -body {
    exec cat "<<Joined to arrows"
} -result {Joined to arrows}
test exec-2.6 {redirecting input from immediate source, with UTF} -constraints {posixUtilsAvailable} -body {
    # If this fails, it may give back:
    # "\uC3\uA9\uC3\uA0\uC3\uBC\uC3\uB1"
    # If it does, this means that the UTF -> external conversion did not 
    # occur before writing out the temp file.
    exec cat << "\uE9\uE0\uFC\uF1"
} -result "\uE9\uE0\uFC\uF1"
test exec-2.7 {redirecting input from immediate source with nulls} -constraints {posixUtilsAvailable} -body {
    exec cat << "Sample\0text"
} -result "Sample\0text"

# I/O redirection: output to file.

file delete gorp.file
test exec-3.1 {redirecting output to file} -constraints {posixUtilsAvailable} -body {
    exec echo "Some simple words" > gorp.file
    exec cat gorp.file
} -result "Some simple words"
test exec-3.2 {redirecting output to file} -constraints {posixUtilsAvailable} -body {
    exec echo "More simple words" | >gorp.file cat | cat
    exec cat gorp.file
} -result "More simple words"
test exec-3.3 {redirecting output to file} -constraints {posixUtilsAvailable} -body {
    exec > gorp.file echo "Different simple words" | cat | cat
    exec cat gorp.file
} -result "Different simple words"
test exec-3.4 {redirecting output to file} -constraints {posixUtilsAvailable} -body {
    exec echo "Some simple words" >gorp.file
    exec cat gorp.file
} -result "Some simple words"
test exec-3.5 {redirecting output to file} -constraints {posixUtilsAvailable} -body {
    exec echo "First line" >gorp.file
    exec echo "Second line" >> gorp.file
    exec cat gorp.file
} -result "First line\nSecond line"
test exec-3.6 {redirecting output to file} -constraints {posixUtilsAvailable} -body {
    exec echo "First line" >gorp.file
    exec echo "Second line" >>gorp.file
    exec cat gorp.file
} -result "First line\nSecond line"
test exec-3.7 {redirecting output to file} -constraints {posixUtilsAvailable} -body {
    set f [open gorp.file w]
    puts $f "Line 1"
    flush $f
    exec echo "More text" >@ $f
    exec echo >@$f "Even more"
    puts $f "Line 3"
    close $f
    exec cat gorp.file
} -result "Line 1\nMore text\nEven more\nLine 3"

# I/O redirection: output and stderr to file.

file delete gorp.file
test exec-4.1 {redirecting output and stderr to file} -constraints {posixUtilsAvailable} -body {
    exec echo "test output" >& gorp.file
    exec cat gorp.file
} -result "test output"
test exec-4.2 {redirecting output and stderr to file} -constraints {posixUtilsAvailable} -body {
    list [exec sh -c "echo foo bar 1>&2" >&gorp.file] \
	    [exec cat gorp.file]
} -result {{} {foo bar}}
test exec-4.3 {redirecting output and stderr to file} -constraints {posixUtilsAvailable} -body {
    exec echo "first line" > gorp.file
    list [exec sh -c "echo foo bar 1>&2" >>&gorp.file] \
	    [exec cat gorp.file]
} -result "{} {first line\nfoo bar}"
test exec-4.4 {redirecting output and stderr to file} -constraints {posixUtilsAvailable} -body {
    set f [open gorp.file w]
    puts $f "Line 1"
    flush $f
    exec echo "More text" >&@ $f
    exec echo >&@$f "Even more"
    puts $f "Line 3"
    close $f
    exec cat gorp.file
} -result "Line 1\nMore text\nEven more\nLine 3"
test exec-4.5 {redirecting output and stderr to file} -constraints {posixUtilsAvailable} -body {
    set f [open gorp.file w]
    puts $f "Line 1"
    flush $f
    exec >&@ $f sh -c "echo foo bar 1>&2"
    exec >&@$f sh -c "echo xyzzy 1>&2"
    puts $f "Line 3"
    close $f
    exec cat gorp.file
} -result "Line 1\nfoo bar\nxyzzy\nLine 3"

# I/O redirection: input from file.

if { ! [catch { exec echo } fid] } {
	exec echo "Just a few thoughts" > gorp.file
}

test exec-5.1 {redirecting input from file} -constraints {posixUtilsAvailable} -body {
    exec cat < gorp.file
} -result {Just a few thoughts}
test exec-5.2 {redirecting input from file} -constraints {posixUtilsAvailable} -body {
    exec cat | cat < gorp.file
} -result {Just a few thoughts}
test exec-5.3 {redirecting input from file} -constraints {posixUtilsAvailable} -body {
    exec cat < gorp.file | cat
} -result {Just a few thoughts}
test exec-5.4 {redirecting input from file} -constraints {posixUtilsAvailable} -body {
    exec < gorp.file cat | cat
} -result {Just a few thoughts}
test exec-5.5 {redirecting input from file} -constraints {posixUtilsAvailable} -body {
    exec cat <gorp.file
} -result {Just a few thoughts}
test exec-5.6 {redirecting input from file} -constraints {posixUtilsAvailable} -body {
    set f [open gorp.file r]
    set result [exec cat <@ $f]
    close $f
    set result
} -result {Just a few thoughts}
test exec-5.7 {redirecting input from file} -constraints {posixUtilsAvailable} -body {
    set f [open gorp.file r]
    set result [exec <@$f cat]
    close $f
    set result
} -result {Just a few thoughts}

# I/O redirection: standard error through a pipeline.

test exec-6.1 {redirecting stderr through a pipeline} -constraints {posixUtilsAvailable} -body {
    exec sh -c "echo foo bar" |& cat
} -result "foo bar"
test exec-6.2 {redirecting stderr through a pipeline} -constraints {posixUtilsAvailable} -body {
    exec sh -c "echo foo bar 1>&2" |& cat
} -result "foo bar"
test exec-6.3 {redirecting stderr through a pipeline} -constraints {posixUtilsAvailable} -body {
    exec sh -c "echo foo bar 1>&2" \
	|& cat |& cat
} -result "foo bar"

# I/O redirection: combinations.

file delete gorp.file2
test exec-7.1 {multiple I/O redirections} -constraints {posixUtilsAvailable} -body {
    exec << "command input" > gorp.file2 cat < gorp.file
    exec cat gorp.file2
} -result {Just a few thoughts}
test exec-7.2 {multiple I/O redirections} -constraints {posixUtilsAvailable} -body {
    exec < gorp.file << "command input" cat
} -result {command input}

# Long input to command and output from command.

set a "0123456789 xxxxxxxxx abcdefghi ABCDEFGHIJK\n"
set a [concat $a $a $a $a]
set a [concat $a $a $a $a]
set a [concat $a $a $a $a]
set a [concat $a $a $a $a]
test exec-8.1 {long input and output} -constraints {posixUtilsAvailable commandLengthLimit} -body {
    exec cat << $a
} -result $a

# More than 20 arguments to exec.

test exec-8.1 {long input and output} -constraints {posixUtilsAvailable} -body {
    exec echo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
} -result {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23}

# Commands that return errors.

test exec-9.1 {commands returning errors} -constraints {posixUtilsAvailable} -body {
    catch {exec gorp456}
} -result {1}
test exec-9.2 {commands returning errors} -constraints {posixUtilsAvailable} -body {
    catch {exec echo foo | foo123} msg
} -result {1}
test exec-9.3 {commands returning errors} -constraints {posixUtilsAvailable} -body {
    list [catch {exec {*}$sleepx 0.1 | false | {*}$sleepx 0.1} msg]
} -result {1}
test exec-9.4 {commands returning errors} -constraints {jim posixUtilsAvailable} -body {
    list [catch {exec false | echo "foo bar"} msg] $msg
} -result {1 {foo bar}}
test exec-9.5 {commands returning errors} -constraints {posixUtilsAvailable} -body {
    list [catch {exec gorp456 | echo a b c} msg]
} -result {1}
test exec-9.6 {commands returning errors} -constraints {jim posixUtilsAvailable} -body {
    list [catch {exec sh -c "echo error msg 1>&2"} msg] $msg
} -result {0 {error msg}}
test exec-9.7 {commands returning errors} -constraints {jim posixUtilsAvailable} -body {
    # Note: Use sleep here to ensure the order
    list [catch {exec sh -c "echo error msg 1 1>&2" \
		     | sh -c "sleep 0.1; echo error msg 2 1>&2"} msg] $msg
} -result {0 {error msg 1
error msg 2}}

# Errors in executing the Tcl command, as opposed to errors in the
# processes that are invoked.

test exec-10.1 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec} msg]
} -result {1}
test exec-10.2 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec | cat} msg] $msg
} -result {1 {illegal use of | or |& in command}}
test exec-10.3 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat |} msg] $msg
} -result {1 {illegal use of | or |& in command}}
test exec-10.4 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat | | cat} msg] $msg
} -result {1 {illegal use of | or |& in command}}
test exec-10.5 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat | |& cat} msg] $msg
} -result {1 {illegal use of | or |& in command}}
test exec-10.6 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat |&} msg] $msg
} -result {1 {illegal use of | or |& in command}}
test exec-10.7 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat <} msg] $msg
} -result {1 {can't specify "<" as last word in command}}
test exec-10.8 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat >} msg] $msg
} -result {1 {can't specify ">" as last word in command}}
test exec-10.9 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat <<} msg] $msg
} -result {1 {can't specify "<<" as last word in command}}
test exec-10.10 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat >>} msg] $msg
} -result {1 {can't specify ">>" as last word in command}}
test exec-10.11 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat >&} msg] $msg
} -result {1 {can't specify ">&" as last word in command}}
test exec-10.12 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat >>&} msg] $msg
} -result {1 {can't specify ">>&" as last word in command}}
test exec-10.13 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat >@} msg] $msg
} -result {1 {can't specify ">@" as last word in command}}
test exec-10.14 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat <@} msg] $msg
} -result {1 {can't specify "<@" as last word in command}}
test exec-10.15 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat < a/b/c} msg] [string tolower $msg]
} -result {1 {couldn't read file "a/b/c": no such file or directory}}
test exec-10.16 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat << foo > a/b/c} msg] [string tolower $msg]
} -result {1 {couldn't write file "a/b/c": no such file or directory}}
test exec-10.17 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat << foo > a/b/c} msg] [string tolower $msg]
} -result {1 {couldn't write file "a/b/c": no such file or directory}}
set f [open gorp.file w]
test exec-10.18 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat <<test <@ $f} msg]
} -result 1
close $f
set f [open gorp.file r]
test exec-10.19 {errors in exec invocation} -constraints {posixUtilsAvailable} -body {
    list [catch {exec cat <<test >@ $f} msg]
} -result 1
close $f

# Commands in background.

test exec-11.1 {commands in background} -constraints {posixUtilsAvailable} -body {
    set x [lindex [time {exec {*}$sleepx 0.2 &}] 0]
    expr $x<1000000
} -result 1
test exec-11.2 {commands in background} -constraints {posixUtilsAvailable} -body {
    list [catch {exec echo a &b} msg] $msg
} -result {0 {a &b}}
test exec-11.3 {commands in background} -constraints {posixUtilsAvailable} -body {
    llength [exec {*}$sleepx 0.1 &]
} -result 1
test exec-11.4 {commands in background} -constraints {posixUtilsAvailable} -body {
    llength [exec {*}$sleepx 0.1 | {*}$sleepx 0.1 | {*}$sleepx 0.1 &]
} -result 3

# Make sure that background commands are properly reaped when
# they eventually die.

exec {*}$sleepx 0.3

test exec-12.1 {reaping background processes} -constraints {posixUtilsAvailable} -body {
    for {set i 0} {$i < 20} {incr i} {
		exec echo foo > exec.tmp1 &
    }
    exec {*}$sleepx 0.1
    catch {exec ps | fgrep "echo foo" | fgrep -v fgrep | wc} msg
    lindex $msg 0
} -cleanup {
    file delete exec.tmp1
} -result 0

# Redirecting standard error separately from standard output

test exec-15.1 {standard error redirection} -constraints {posixUtilsAvailable} -body {
    exec echo "First line" > gorp.file
    list [exec sh -c "echo foo bar 1>&2" 2> gorp.file] \
	    [exec cat gorp.file]
} -result {{} {foo bar}}
test exec-15.2 {standard error redirection} -constraints {posixUtilsAvailable} -body {
    list [exec sh -c "echo foo bar 1>&2" \
		| echo biz baz >gorp.file 2> gorp.file2] \
	    [exec cat gorp.file] \
	    [exec cat gorp.file2]
} -result {{} {biz baz} {foo bar}}
test exec-15.3 {standard error redirection} -constraints {posixUtilsAvailable} -body {
    list [exec sh -c "echo foo bar 1>&2" \
	        | echo biz baz 2>gorp.file > gorp.file2] \
	    [exec cat gorp.file] \
	    [exec cat gorp.file2]
} -result {{} {foo bar} {biz baz}}
test exec-15.4 {standard error redirection} -constraints {posixUtilsAvailable} -body {
    set f [open gorp.file w]
    puts $f "Line 1"
    flush $f
    exec sh -c "echo foo bar 1>&2" 2>@ $f
    puts $f "Line 3"
    close $f
    exec cat gorp.file
} -result {Line 1
foo bar
Line 3}
test exec-15.5 {standard error redirection} -constraints {posixUtilsAvailable} -body {
    exec echo "First line" > gorp.file
    exec sh -c "echo foo bar 1>&2" 2>> gorp.file
    exec cat gorp.file
} -result {First line
foo bar}
test exec-15.6 {standard error redirection} -constraints {posixUtilsAvailable} -body {
    exec sh -c "echo foo bar 1>&2" > gorp.file2 2> gorp.file \
	    >& gorp.file 2> gorp.file2 | echo biz baz
    list [exec cat gorp.file] [exec cat gorp.file2]
} -result {{biz baz} {foo bar}}
test exec-15.7 {combine standard output/standard error} -constraints {posixUtilsAvailable} -body {
    exec sh -c "echo foo bar 1>&2" > gorp.file 2>@1
    exec cat gorp.file
} -cleanup {
    file delete gorp.file gorp.file2
} -result {foo bar}

test exec-16.1 {flush output before exec} -constraints {posixUtilsAvailable} -body {
    set f [open gorp.file w]
    puts $f "First line"
    exec echo "Second line" >@ $f
    puts $f "Third line"
    close $f
    exec cat gorp.file
} -cleanup {
    file delete gorp.file
} -result {First line
Second line
Third line}

file delete sleepx

testreport
